import Foundation

/// A type that can be used as an identifier.
///
/// When creating identifiers for a new context, you would normally start with the `initial` identifier.
/// Then, you can use the `next()` method to create additional identifiers.
///
/// This type is designed to be convenient (and efficient) to use if there’s an unbroken chain of identifier creation,
/// for example when used in a local database.
///
/// Any identifier generated by `next()` is guaranteed to be different from any other identifiers in its “history”.
/// That is, the following assertion guaranteed to hold, even if the `identifier` is encoded/decoded multiple times:
///
/// ```
/// let identifiers = SequentialIdentifier.initial.nextIdentifiers()
///
/// Set(identifiers.prefix(n)).count == n // always true
/// ```
///
/// No equality guarantees are made otherwise. Specifically:
///
/// ```
/// serializedInitialFromAPreviousRun == .initial // may be false
/// identifier.next() == identifier.next() // may be false
/// ```
///
struct SequentialIdentifier: Hashable {
    private var value: Int
    
    static let initial = SequentialIdentifier(value: 1)
    
    /// Produces a new identifier.
    ///
    /// See `SequentialIdentifier` for uniqueness guarantees of the returned identifier.
    ///
    /// - Returns: A new identifier.
    func next() -> SequentialIdentifier {
        return SequentialIdentifier(value: value + 1)
    }
}

extension SequentialIdentifier {
    
    /// Convenience for returning a sequence of unique identifiers following the receiver.
    ///
    /// Each new identifier has the same guarantees as calling `next()` on its previous identifier in the sequence.
    ///
    /// - Returns: An infinite sequence of identifiers following the current identifier.
    func nextIdentifiers() -> AnySequence<SequentialIdentifier> {
        struct SequentialIdentifierIterator: IteratorProtocol {
            var current: SequentialIdentifier
            mutating func next() -> SequentialIdentifier? {
                current = current.next()
                return current
            }
        }
        
        return AnySequence { SequentialIdentifierIterator(current: self) }
    }
    
}

extension SequentialIdentifier: Codable {
    
    init(from decoder: Decoder) throws {
        self.init(value: try decoder.singleValueContainer().decode(Int.self))
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(value)
    }
    
}
